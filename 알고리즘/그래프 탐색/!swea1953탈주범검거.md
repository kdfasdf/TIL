https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq

## 풀이
풀릴 듯 안풀릴 듯 하다가 굉장히 오랜시간동안 풀어버린 문제였다 <br>
문제 설명이 살짝 부족한 부분이 있는데 탈주범은 '1시간에 1만큼 이동할 수 있다'는 그 자리에 그대로 있을 수 도 있고 1 이동했을 수도 있다는 의미였다<br>
파이프 모양에 따라 이동할 수 있는 움직임 유형이 정해져 있는데 중요한 것은 지금 위치한 위치의 파이프가 움직일 위치에 있는 파이프와 물리적으로 연결되어 있어야 한다는 것이다
- python
```
def bfs(x, y, time):
    q = []
    q.append([x, y, 1])
    visited[x][y] = 1
    while q:
        nx, ny, ntime = q.pop(0)
        if ntime == l:
            continue
        for j in range(len(move[data[nx][ny]])):
            tx = nx + move[data[nx][ny]][j][0]
            ty = ny + move[data[nx][ny]][j][1]
            ttime = ntime + 1
            if 0 <= tx < n and 0 <= ty < m and ttime <= l and data[tx][ty] != 0 and visited[tx][ty]==0:
                for mx, my in move[data[tx][ty]]:
                    if move[data[nx][ny]][j][0] == -mx and -my==move[data[nx][ny]][j][1]:
                        q.append([tx, ty, ttime])
                        visited[tx][ty] = ttime


t = int(input())
move = [[],
        [[1, 0], [-1, 0], [0, 1], [0, -1]],
        [[1, 0], [-1, 0]],
        [[0, 1], [0, -1]],
        [[-1, 0], [0, 1]],
        [[1, 0], [0, 1]],
        [[1, 0], [0, -1]],
        [[-1, 0], [0, -1]],
        ]
for test in range(1, t + 1):
    n, m, r, c, l = map(int, input().split())
    data = []
    visited = [[0] * m for _ in range(n)]
    for _ in range(n):
        data.append(list(map(int, input().split())))
    bfs(r, c, 1)
    result = 0
    for i in range(n):
        for j in range(m):
            if 0 < visited[i][j] <= l:
                result += 1

    print('#{}'.format(test), result)
```
