![image](https://github.com/kdfasdf/TIL/assets/96770726/c25c0f79-d885-4b1f-b298-27aeb8792b79)

- 예제 입력 1
```
4 4
3 0 1 4
```

- 예제 출력 1
```
5
```

- 예제 입력 2
```
4 8
3 1 2 3 4 1 1 2
```

- 예제 출력 2
```
5
```

- 예제 입력 3
```
3 5
0 0 0 2 0
```

- 예제 출력 3
```
0
```


## 풀이
빗물이 고이는 모양인지를 체크하고 밑변*높이의 합 - k(블록 합)으로 구하려고 했으나 쉽지 않았음
아래 풀이로 더 쉽게 해결 가능
1. 빗물 리스트의 특정 위치 i를 기준으로 좌측 블록 중 가장 높은 블록과 우츨 블록 중 가장 높은 블록을 조사한다
2. 조사한 두 블록 중 작은 블록을 선택한다
3. 현재 위치의 블록의 높이가 2. 에서 선택한 블록의 높이보다 낮으면 물이 고이므로 (2.에서 구한 블록의 높이 - 현대 위치의 블록 높이)를 구한다
4. 위의 과정을 모든 위치에 대해서 수행하고(처음과 끝 제외) 더한다

- python 

```
h,w=map(int,input().split())
data=list(map(int,input().split()))
result=0
for i in range(1,len(data)-1):
    leftMax=max(data[:i])
    rightMax=max(data[i+1:])
    temp=min(leftMax,rightMax)
    if data[i]<temp:
        result+=temp-data[i]
print(result)
```
<br>

<br>

- Java

```
import java.util.*;
 public class Main{
     public static int n,m;
     public static int[] data;
     public static void main(String[] args){
         Scanner sc = new Scanner(System.in);
         n=sc.nextInt();
         m=sc.nextInt();
         int result=0;
         data=new int[m];
         for(int i=0;i<m;i++){
             data[i]=sc.nextInt();
         }
         for(int i=1; i<m-1;i++){
             int leftMax=0;
             int rightMax=0;
             for(int j=0; j<i;j++)
             {
                 leftMax=Math.max(leftMax,data[j]);
             }
             for(int j=i+1;j<m;j++){
                 rightMax=Math.max(rightMax,data[j]);
             }
             int height=Math.min(rightMax,leftMax);
             if(data[i]<height){
                 result+=height-data[i];
             }
         }
         System.out.println(result);
     }
 }
```
