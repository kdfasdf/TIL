## 서론
최근 프로그머스 문제들을 밀고 있는데 해시 관련 문제에서 막힘이 있어서 겸사겸사 해시 관련 개념을 정리해보려고 한다.
<br>
### 해시테이블
해시 테이블 또는 해시맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조
- 해시 테이블의 가장 큰 특징은 대부분의 연산 분할 상환 분석에 따른 시간 복잡도가 O(1)
  - 데이터양에 관계 없이 빠른 성능을 기대할 수 있음
 
### 해시
해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용할 수 있는 함수
- 예시
  - word      ->  r1
  - a         ->  r2
  - sentence  ->  r3

해시테이블을 인덱싱 하기 위해 해시 함수를 사용하는 것을 해싱이라고 한다.
<br>
성능 좋은 해시 함수들의 특징은 다음과 같다.
- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
- 해시 테이블 사용 효율이 높을 것

<br>

해시테이블의 성능에는 충돌을 최소화 하는 것이 중요하다 우리가 생각하는거와 다르게 충돌은 생각보다 쉽게 일어날 수 있는 문제인데 이산구조에서 접했던 생일 문제와 비둘기집의 원리로 충돌이 얼마나 자주 일어나는지 체감해보자
<br>

### 비둘기집 원리와 생일 문제
비둘기집의 원리는 n개의 비둘기가 m개의 둥지에 넣을 때 n>m이면 적어도 한 둥지에는 2마리 이상이 있는 원리이다
생일 문제는 임의의 사람을 모았을 때 생일이 겹치는 사람이 존재할 확률을 구하는 문제이다. 비둘기 집의 원리에 따라 366명 이상이 모이면 반드시 생일이 같은 2명이 존재한다. 그렇다면 생일이 같을 확률이 절반정도가 되려면 몇 명정도 모여야 할까? 
놀랍게도 23이 모이면 약 50%이고 60명 정도 되면 99%이다 
이를 코드로 구현해보면 아래와 같다
```
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
public class Main{
    public static void main(String[] args){
        int sameBirthday=0;
        for(int i=0;i<100000;i++)// 10만번 실험
        {
            int[] birthdays=new int[23];
            for(int j=0;j<23;j++)
            {
                int birthday= ThreadLocalRandom.current().nextInt(1,365+1);
                if(IntStream.of(birthdays).anyMatch(x->x==birthday)){
                    sameBirthday++;
                    break;
                }
                birthdays[j]=birthday;
            }
        }
        System.out.print("10만 번 실험 중 생일이 같은 실험의 확률: ");
        System.out.print((double) sameBirthday/100000*100);
        System.out.println("%");
    }
}
```
실행 결과
```
10만 번 실험 중 생일이 같은 실험의 확률: 50.639%
```
60명에 대한 실험은 위 코드에서 23을 60으로만 바꿔주면 된다<br>

실행 결과
```
10만 번 실험 중 생일이 같은 실험의 확률(60명): 99.442%
```

![image](https://github.com/kdfasdf/TIL/assets/96770726/96253577-8c6f-4372-a1ab-15d81acc7cfa)



### 해시함수(모듈로 연산)
충돌을 최소화하기 위한 해싱기법은 다양한데 가장 대표적인 모듈로 연산을 이용한 나눗셈 방식은 다음과 같다<br>
- h(x)=x mod m 

여기서 h(x)는 입력값 x의 해시 함수를 통해 생성된 결과다. m은 해시 테이블의 크기로 일반적으로 2의 거듭 제곱에 가깝지 않은 소수를 선택한다 h(x)는 모듈로 연산의 결과로 매우 단순한 방법이지만 이미 많은 키 세트가 충분히 랜덤한 상태이고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로는 잘 동작한다.
x는 어떤 간단한 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키의 값이다. <br>
이펙티브 자바의 저자 조슈아 블로크는 자바를 설계할 때, 값 x를 다음과 같이 다항식의 결과로 정의했다
- p(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]

여기서 x는 31로 하는 거듭제곱 P(31)의 연산의로 정의했다고 밝혔다. 조슈아 블로크는 여러 해시 함수의 성능을 조사했고 'The C Programming Language' 책에서 다음과 같이 P(31)을 찾아냈다
```
unsigned hash(char *s){
  unsigned hashval;
  for(hashval=0;*s!='\0';s++)
    hashval=*s+31*hashval;
  return hashval%HASHSIZE;
}
```
이 형태가 성능과 충돌의 적절한 합의점이었는데 31은 메르센 소수로 수학적으로도 나쁘지 않은 선택이기도 하다
- JDK에 포함된 해시 코드 중 일부
```
hashCode = 31 * hsahCode + (e==null? 0 : e.hashCode)
```
### 충돌
사실상 모든 해시 테이블에서 충돌 문제가 일어날 수 밖에 없는데 충돌이 발생할 경우 충돌을 처리하는 대표적인 방법을 알아보자
- 개별 체이닝
![image](https://github.com/kdfasdf/TIL/assets/96770726/73dc1ee2-acb7-4746-a156-2546971b5133)

충돌 발생 시 연결리스트로 연결하는 방식충돌이 발생한 윤아와 서현은 윤아 다음 아이템으로 서현으로 연결리스트로 연결된다.
잘 구현된 경우 탐색 복잡도는 O(1)이지만 최악의 경우 O(n)이다. 자바 8의 해시 테이블 구현체인 HashMap은 연결리스트 구조를 좀 더 최적화해서, 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태를 병행하기도 한다.

### 오픈 어드레싱(선형탐사방식)
![image](https://github.com/kdfasdf/TIL/assets/96770726/bab6916e-8a22-43ba-928c-94eae20bc3f6)

충돌 발생 시 핻아 위치부터 순차적으로 탐색하다 빈 위치에 삽입하는 방식이다 윤아와 서현이 충돌이 일어나고 그 다음 빈칸인 17에 서현이 저장되었다 이런 선형탐사 방식의 오픈 어드레싱의 문제는 데이터가 고르게 분포되지 않고 뭉쳐질 수 있는 것이다 해시테이블에서 연속된 데이터 그룹이 생기는 것을 클러스터링이라 하는데 
클러스터들이 점점 커지면 인근 클러스터들과 서로 합쳐지는 일이 발생한다. 그렇게 되면 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다음 위치에는 데이터가 거의 없는 상태가 될 수 있는데 이러면 탐사시간이 오래걸리게 되어 해싱 효율이 떨어지게 된다. 오픈 어드레싱 방식은 버킷의 크기보다 큰 경우
삽입이 불가능하다 따라서 일정 이상 채워지면 그로스팩터의 비율에 따라 더 큰 크기의 또다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱 작업이 일어난다. (자바에서 HashMap의 로드팩터와 그로스 팩터는 각각 0.75,2로 해시맵의 75%이상이면 2배 더 큰 메모리 영역을 새롭게 할당한다)

언어별 테이블 구현 방식
![image](https://github.com/kdfasdf/TIL/assets/96770726/35cb55cb-ee74-4f3a-80d6-14c8e85fa290)
체이닝과 선형 탐사 방식의 로드 팩터에 따른 성능 차이는 위와 같다 <br>
자바 같은 경우 연결 체이닝 방식으로 ahshmap이 구현되어 있는데 연결리스트 구조를 좀 더 최적화하여 데이터의 개수가 많아지면 레드 블랙 트리에 저장하는 형태를 병행한다
|언어|방식|
|--|--|
|C++(GCC)|개별 체이닝|
|자바|개별 체이닝|
|고(GO)|개별 체이닝|
|루비|오픈 어드레싱|
|파이썬|오픈 어드레싱|
