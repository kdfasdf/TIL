### 워밍업
1. http://www.cyber.co.kr에서 www는 무엇을 나타내는걸까?
2. 아래의 URL 중 어느 것이 올바른 표기일까?
   - (a) http://www.cyber.co.kr
   - (b) http://www.cyber.co.kr
3. 인터넷에 접속한 PC나 서버를 식별하기 위한 어드레스를 무엇이라고 할까?
4. 웹 서버의 이름에서 IP어드레스를 알아 내기 위한 서버를 무엇이라고 할까?
5. DNS 서버에 문의 메시지를 보내는 프로그램을 무엇이라고 할까?

<br>

1. 웹 서버의 이름
   - www는 서버의 이름이다. 서버의 이름은 마음대로 붙일 수 있으므로 www라는 이름은 필요 없다
2. (b)
   - URL에는 서버명과 파일의 경로명을 모두 쓰게 되어있는데 맨 끝의 /(루트 디렉토리)가 없다면 경로명을 쓰지 않은 것
3. IP주소
   - IP 어드레스는 전화번호같은 것이다 네트워크에 접속한 PC나 서버에는 모두 다른 IP 어드레스를 할당하도록 되어 있다

4. DNS 서버
   - DNS 서버에는 이름과 주소의 대응 관계가 등록되어 있으며, 서버의 이름으로 IP 어드레스를 조회할 때는 DNS 서버에 질의한다

5. 리졸버
   - DNS 서버에 질의할 때 웹 브라우저는 리졸버를 호출하여 DNS 서버에 메시지를 보내도록 한다

<br><br><br>

## section1 - URL을 입력해서 여행을 시작하자
- 웹 브라우저
  - HTTP, FTP, 메일 클라이언트들의 기능을 가지고 있는 클라이언트 소프트웨어
- 프로토콜
  - 데이터를 전송하는 규칙
- URL
  - 웹에 있는 문서나 페이지 등에 이름을 붙이는 방법. 웹 페이지 이외에 FTP 서버에 있는 파일이나 메일 주소 등도 URL로 표현할 수 있다.
- FTP
  - 인터넷에서 사용되는 파일 전송용 프로토콜, FTP 프로토콜을 사용하여 파일을 전송하는 프로그램도 FTP라고 한다
- 도메인
  - 도메인은 네트워크 영역을 가리키는 말이며, 도메인 명은 그 영역의 이름이다. 네트워크는 여러 가지 도메인이 있는데,  단순히 도메인 또는 도메인명이라고 한 경우는 인터넷의 컴퓨터를 관리하는
  - 도메인 네임 시스템의 영역이나 이름을 가리키는 일이 많다. 또한 마침표를 기준으로 계층화 되어있다(ex naver.com)
- 웹 서버
  - 웹 서비스를 하는 서버 소프트웨어를 말한다 HTTP라는 프로토콜을 통해 요청되는 클라이언트의 요구에 따라 웹 페이ㅣ의 데이터를 클라이언트로 보낸다. HTTP 라는 프로토콜을 이용하는 서버이므로 HTTP 서버, HTTP 데몬이라고 부르기도 한다. 
 
- 포트 번호
  - TCP/IP 소프트웨어가 상위 계층의 애플리케이션을 식별하기 위해 사용하는 번호를 말한다
  - TCP/IP 소프트웨어는 포트 번호를 이용하여 수신된 데이터를 올바른 애플리케이션에게 전달한다

## section2 - 웹 브라우저는 먼저 URL을 해석한다.
웹 브라우저는 프로토콜에 따라 해석하는 방식이 달라진다. 여기서는 웹 서버에 HTTP프로토콜로 액세스 하는 예를 살펴보겠다.
```
1:'http:' + 2:'//' + '웹서버명' + 3:'/' '디렉토리명' +'/' + '파일명'
```
1. URL의 선두는 데이터 소스에 접근하는 구조, 즉 프로토콜을 기술
2. //는 뒤에 이어지는 문자열이 서버의 이름임을 나타낸다
3. 데이터(파일)의 경로명을 나타낸다

## section3 - 파일과 디렉토리의 차이

아래 두 URL 표기 차이를 알아보자

1. http://www.cyber.co.kr/
2. http://www.cyber.co.kr

1. 과 같이 '/'(루트 디렉토리) 아래에 파일 명이 생략되면 웹 서버는 미리 설정해둔 파일의 이름이 지정된 것으로 간주하여 index.html와 같이 기본으로 설정된 파일을 보내준다
2. 디렉토리 까지 생략되어 무엇을 요구하는지 전혀 알 수 없게된 상황이지만 이것을 틀린 것으로 처리하면 오류 사례가 너무 많아지므로 예외적으로 2. 처럼 썼을 경우 끝에 '/'가
   붙어 있는 것으로 간주하는 것이 일반적이다

## section4 - HTTP의 기본 개념
HTTP 프로토콜을 서버와 클라이언트가 메시지를 주고 받는데 있어서 클라이언트 쪽에서 서버에 메시지를 보낼 때 무엇을 어떻게 와 같은 메시지를 보내고 서버쪽에서 그에 따른
응답 메시지를 다시 보내는 프로토콜이다

<br>

여기서 무엇에 해당하는 것은 URI라고 한다 보통 웹 페이지의 파일명이나 CGI 프로그램의 파일명이 URI가 된다 다음으로 어떻게에 해당하는 것은 메서드이다

- URI
   - 웹 문서나 페이지 등에 이름을 붙일 때 사용하는 통일된 방식. 홈페이지 등의 이름을 붙이는데 사용하는 URL은 URI라는 체계 안에 포함되는 것으로 URI쪽이 적용 범위가 더 넓다.
- CGI
  - 웹 서버의 백 엔드에서 서버 애플리케이션을 동작시킬 때 웹 ㅓㅅ버에서 서버 애플리케이션을 호출하기 위한 대표적인 프로그램

## section5 - HTTP리퀘스트 메시지를 만든다
javawebserver 요구사항 참고 https://github.com/kdfasdf/javawebserver/blob/main/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD1-1~1-4%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B81.md

## section6 - 리퀘스트를 보내면 리스폰스가 돌아온다.
HTTP 메서드

|메서드|HTTP 1.0|HTTP 1.1|의미|
|--|--|--|--|
|GET|O|O|URI로 지정한 정보를 꺼낸다. 파일의 경우 그 파일의 알맹이를 반송한다. CGI 프로그램의 경우는 그 프로그램의 출력 데이터를 그대로 반송한다|
|POST|O|O|클라이언트에서 서버로 데이터를 송신한다 폼에 입력한 데이터를 송신하는 등에 사용한다|
|HEAD|O|O|GET과 거의 같다. 단, HTTP 메시지 헤더와 상태줄만 반환, body부분 제외. 파일의 최종 갱신 일시 등의 속성 정보를 살펴볼 때 사용한다|
|OPTIONS||O|대상 리소스에 대한 통신 가능 옵션(메서드)를 설명(주로 CORS)|
|PUT|△|O|URI로 지정한 서버에 있는 파일을 변경한다 URI로 지정한 파일이 없는 경우 파일을 새로 작성한다|
|TRACE||O|최종 destination까지의 Loopback 테스트 하기 위함|
|PATCH||△|PUT과 마찬가지로 서버에 있는 정보를 변경,(PUT은 전체 변경, PATCH는 일부 변경)|
|DELETE||O|특정 리소스를 지우기 위함|

O: 각 버전에서의 표준
△: 정식 표준이 아닌 부가 기능으로서의 표준 부록에 기술되어 있는 것

<br>
<br>

응답 상태코드는 추후에 TIL HTTP 폴더에 정리

만약 서버로부터 받은 응답메시지가 문장 뿐이라면 한번만 받으면 끝난다. 만약 응답 메시지에 이미지 파일을 나타내는 태그 제어정보가 포함되어 있으면
웹 브라우저는 화면에 표시할 태그를 찾고 그림이 차지할 공간을 비워두고 다시한번 웹 서버에 접근하여 그림파일을 요청한다. 그리고 서버는 요청받은 이미지 파일을
응답으로 보내준다


## section 7 수신측 웹 서버의 IP 주소를 조회한다
웹 브라우저는 URL을 해석하거나 HTTP 메시지를 만드는 기능은 있지만, 그 메시지를 네트워크에 보내는 기능은 없다. 그 기능은 OS가 가지고 있으므로 웹 브라우저에는 필요하지 않다. 그러므로 메시지를 보낼 때는 OS에 요청하여 보내게 된다.

그러나 현재 단계에서는 웹 서버에 메시지를 보낼 수 없다. OS에 데이터 송신을 요청할 때는 송신 데이터와 함께 송신 상대의 IP 주소를 OS에 알려주어야 한다. 


<br>

그렇다면 URL에 서버명이 아니라 IP 주소를 쓰는 편이 좋지 않을까 하는 의문이 생길 수도 있다. 실제로 서버명 대신 IP 주소를 써도 올바르게 동작한다. 그러나 여러 개의 전화 번호를 외우는 것이 힘들듯이, 수많은 IP 주소를 외우는 것은 쉽지 않다. 이름이 숫자보다 외우기 쉬운 것과 같이 URL을 쓸 때에도 서버명을 쓰는 편이 알기 쉽다

<br>

IP 주소 같은 것은 없애고 이름으로 상대를 지정하여 통신할 수 있게 하면 되지 않을까 하는 의견도 있다. 인터넷은 최신의 네트워크 기술을 사용하고 있으니, 전화와는 달리 그 정도는 가능하지 않느냐고 생각하는 사람이 있어도 이상한 것은 아니다.

<br>

그것을 설명하기 전에 먼저 IP 주소의 역할을 설명하겠다. 인터넷에서 데이터를 운반할 때는 데이터가 흘러가는 곳을 라우터라는 기기로 컨트롤한다. 통신할 상대의 IP 주소가 필요한 이유는 여기에 있다. IP 주소가 없으면 그 컨트롤을 할 수 없으므로 데이터를 상대에게 보낼 수 없다. 그렇다는 것은 라우터가 IP 주소 대신 이름을 써서 데이터의 흐름을 컨트롤한다면, IP 주소 대신 이름으로 상대와 통신할 수 있게 될 것이다. 확실히 이론적으로는 그것도 가능하다. 그러나 데이터의 양이라는 관점에서 이름과 IP 주소를 비교하면 큰 차이가 있다.

<br>

IP 주소는 32 비트, 즉 4바이트면 되는데 도메인의 최대 길이는 255바이트나 된다 그러므로 이름을 이용하여 데이터의 행선지를 컨트롤하게 되면, 라우터는 훨씬 더 많은 데이터를 처리해야 하기 때문에 처리 효율이 저하되고 저ㄴ체적인 네트워크 속도가 느려질 것이 자명하다.  대신 IP주소를 이름으로 매칭하는 DNS를 사용한다

## section 9 리졸버 DNS 서버 질의 던지는 과정
DNS 서버에 질의한다는 것은 DNS 서버에 질의 메시지를 보내고 그곳에서 응답 메시지를 받는 것을 의미함 이것을 DNS 서버에 대하여 클라이언트로서 동작한다고 할 수 있다. DNS 클라이언트에 해당하는 것을 DNS 리졸버라고 함
- Socket 라이브러리는 리졸버의 기능을 포함하고 있음
  - 리졸버의 프로그램명과 웹 서버의 이름을 기술하여 리졸버를 호출할 수 있음
  - 리졸버를 호출하면 DNS 서버에 질의 메시지를 보내고 응답메시지가 돌아옴
  - 이 응답 메시지에 IP주소가 들어있고 리졸버는 이 IP 주소를 꺼내서 리졸버를 호출할 떄 지정되었던 메모리에 IP 주소를 써넣음
  - 웹 서버에 메시지를 보낼 떄 지정된 메모리 영역에서 IP 주소를 꺼내어 HTTP 리퀘스트 메시지와 함께 OS로 넘겨서 전송을 요청
 
## section 10
그림 참고
- 리졸버 호출 후 제어가 리졸버의 내부로 옮겨짐
- 리졸버로 제어가 옮겨지면 질의 메시지를 만들음
- DNS 표준사양에 따른 'www.cyber.co.kr'이라는 서버의 IP 주소를 가르쳐 주세요라는 의미를 가지는 바이너리 형식의 데이터를 만들음
- 먼둔 메시지를 DNS 서버로 보냄
- 이 때 메시지 송신은 리졸버가 자체에서 실행하는 것이 아닌 OS 내부에 있는 TCP/IP 프로토콜 처리 소프트웨어를 호출하여 실행을 맡기는 것임

물론 DNS 서버에 질의 문자열을 보내려면 DNS 서버의 IP 주소를 알아야한다 컴퓨터 TCP/IP 설정에서 DNS 서버 설정을 할 수 있다.

## section 11
그림 참고
'www.cyber.co.kr'이라는 이름을 가진 서버이 IP 주소를 알아낼 때, 클라이언트는 다음 정보를 포함하는 질의 메시지를 DNS 서버에 보낸다 <br>
a) 이름 = www.cyber.co.kr <br>
b) 클래스 = IN <br>
c) 타입 = A <br>
그러면 DNS 서버는 등록 정보 중에서 이 세 가지에 해당하는 것을 찾게 된다. <br>

|문의 항목|설명|
|--|--|
|이름|서버나 메일 배송처(메일 주소 @ 이후의 이름) 등의 이름|
|클래스|이름의 클래스를 나타낸다. DNS의 구조가 고안되었을 때는 인터넷 이외의 네트워크에서의 이용도 고려되어있었기 떄문에 클래스를 두었다 하지만 지금은 인터넷 이외에서는 사용되지 않으므로 클래스는 언제나 인터넷을 나타내는 IN이라는 값을 사용한다|
|타입|이름의 타입을 나타낸다. 그 타입에 따라서 클라이언트에 회답하는 정보의 내용이 달라진다. <br> A:등록되어 있는 이름이 서버명임을 나타내고, 클라이언트에는 IP 주소를 회답한다. <br> MX: 이름은 메일 배송처를 나타내고, 메일 서버의 도메인명, 우선 순위, IP 주소 등을 회답한다.|

<br>

## section 12 - DNS 서버에 질의하는 패킷
- 리졸버가 DNS 서버에 보내는 질의 메시지의 실체는 하나의 패킷이다. 이 UDP 표준 사양에 따라 만들어진 패킷이다. DNS 서버는 이 패킷을 받아 서버명에 대응하는 IP주소를 를 찾아내고 응답메시지에 넣어서 클라이언트에 되돌려준다.
- 그 패킷은 네트워크를 통해 클라이언트측으로 도착하고 ,TCP/IP 소프트웨어를 통해 리졸버로 넘겨지며, 리졸버가 내용을 해석한 후 IP 주소를 애플리케이션에게 넘긴다. 이 떄 실제롤 지정한 메모리 영역에 IP 주소를 저장한다
- 이것으로 리졸버의 동작이 끝나고, 제어가 애플리케이션으로 되돌아온다. 애플리케이션은 메모리 영역에 저장한 IP 주소를 필요할 때 꺼낼 수 있으므로, 이것으로 IP 주소가 애플리케이션에 넘겨진 것이다.
- UDP
  - TCP/IP 프로토콜군 중의 하나로 TCP와 마찬가지로 데이터 송수신을 제어하는 역할을 가지고 있으나 접속 절차나 오류 시의 재전송 처리, 흐름제어, 순서 제어 등을 하지 않고 개개인 패킷을 서로 다른것으로서 전송한다. 접속 동작을 하지 않으므로 짧은 데이터를 주고받는데 적합하다.

## section 13 - DNS 서버의 담당 범위와 계층 구조
보통 DNS 서버에는 회사 내의 웹 서버나 메일 서버를 등록해둔다. 그러나 회사 바깥의 서버까지 전부 등록할 수는 없으므로 , 질의한 이름이이 DNS 서버에 등록되어 있지 않은 경우도 있다
<br>
- 질의한 서버 이름이 DNS 서버에 등록되어있지 않으면 해당 서버명이 등록되어 있는 DNS서버를 찾아내 그곳에 질의를 던져 IP 주소를 조회하게된다.
- DNS 에서 다루는 이름은 www.cyber.co.kr과 같이 마침표로 구분하여 계층화 되어 있으며, 오른쪽에 있는 이름이 상위의 계층을 나타낸다. (상위 계층 순:kr -> co ->cyber)
- 이와같이 계층화된 도메인의 하나하나가 DNS 서버의 담당 범위를 나타내는 단위가 된다. 즉 cyber.co.kr이나 www.cyber.co.kr이라는 도메인 하나하나가 DNS 서버의 담당 범위를 나타낸다
   다만 하나의 도메인이 최소단위가 되므로 그것을 여러 개의 DNS 서버로 분할하여 담당할 수는 없다. 하나의 도메인을 여러 개의 DNS 서버로 나누고 싶을 때는도메인 하위에 위치하는 서브 도메인을 여러개 만들어야 한다

- 서브 도메인
서브도메인이란 도메인의 보조로 기능별로 웹사이트의 섹션을 구분하기위해 도메인 이름에 추가되는 prefix를 의미한다
- blog.naver.com
- mail.naver.com
- finance.naver.com

## section 14 - DNS 서버 찾는 과정(그림 참고 필수)
웹 서버가 등록되어 있는 DNS 서버를  찾아내는 방법
- 인터네셍는 DNS 서버가 몇만 대가 있으므로 일일이 찾아 헤맬 수는 없음(가까운 DNS 서버에 인터넷의 DNS 서버를 전부 등록할 수도 없음)
- DNS 서버를 찾을 수없다면 질의 메시지를 보낼 수 없음
<br>
-> 하위 도메인을 담당하는 DNS 서버를 한 단계 상위 도메인으 DNS 서버에 등록하는걸 반복하는 방식으로 등록
  - cyber.co.kr이라는 도메인을 담당하는 DNS 서버를 co.kr 의 DNS 서버에 등록하고 , co.kr의 DNS 서버를 kr 도메인의 DNS 서버에 등록하는 방식
- top level domain
  - com, kr 등 맨 끝에 붙여져있는 도메인(www.cyber.co.kr 에서는 kr)
- 루트 도메인
  - top level domain의 상위에 있는 도메인
  - 루트 도메인은 com이나 kr 같은 도메인 명이 없으므로, 일반적으로 도메인명을 쓸 때는 생략하지만 명시적으로 쓸 때는 .을 붙여 루트 도메인을 나타낸다 dns 서버에 마지막으로 등록되는 도메인(루트 도메인 서버는 13대 밖에 없음)

## section 15 - 캐시 기능을 통한 DNS 서버의 빠른 응답
DNS에서 서버를 찾아가는 개념은 section14와 같지만 실제로는 kr 에서 cyber.co.kr로 건너뛰어서 탐색하거나 심지어 최상의 루트 도메인부터 차례로 탐색해 간다는 원칙대로 동작하지 않을 때도 있음<br>
-> 이는 DNS가 한번 조회했던 이름을 캐시에 기록해두는 기능이 있기 때문 
<br>
단점 
- 캐시에 정보를 저장한 후 등록 저보가 변경되는 경우 캐시로 저장한 정보가 정확하지 않음
  - 캐시에 저장한 데이터의 유효기간을 설정하여 해결
 
## section 16 - TCP/IP 소프트웨어 중재자, Socket 라이브러리 이 책에서 소켓에 대한 설명이 약하니 section 16~22 내용은 다른책에서 보충해야하자
이 책에서 소켓은 애플리케이션에서 요청된 것을 TCP/IP 소프트웨어에 전달하는 역할정도 까지만 알고 넘어간다

## section 17 - 소켓을 생성하여 접속 상황을 관리한다 
- 리졸버를 호출하여 웹 서버의 IP 주소를 얻어오고나서 Socket 라이브러리 내의 socket라는 프로그램을 호출하고 TCP/IP 소프트웨어에게 송수신할 준비를 마친다.
- TCP/IP 소프트웨어는 애플리케이션이 어떤 상태에 있는지 항상 파악하고 움직인다. 그릴 위한 제어 정보 등을 보관하는 메모리 영역을 마련하는 것이 준비작업의 주된 목적이다
- 이 준비 작업을 보통 소켓을 만든다라고 한다

- 디스크립터
  - TCP/IP 소프트웨어는 디스크립터라는 값을 애플리케이션에 보낸다(웹의 경우 웹 브라우저)
  - 컴퓨터는 동시에 많은 브라우저를 실행할 수 있기 떄문에, 여러 개의 애플리케이션들이 TCP/IP 소프트웨어를 통해서 동시에 데이터를 송수신함
  - 이 때 TCP/IP 소프트웨어가 개개의 애플리케이션을 식별하기 위해 각 애플리케이션에 넘기는 일종의 번호표와 같은 것이 디스크럽터이다

<br>

이 책에서는 디스크립터에 대한 설명을 위처럼 하고 있는데 읽어보면 port번호와 좀 개념이 겹치는 것 같아 찾아보았다
- 디스크립터
  - 브라우저에서 창 2개를 열면 2개의 데이터 송수신 동작이 동시에 진행되므로 2개의 소켓이 필요하다. 디스크립터는 이 두개의 소켓을 구별하는 식별번호이다.
- 포트번호
  - 호스트 내에 어플리케이션이 동작하고 네트워크를 통해 데이터를 주고받을 때 애플리케이션을 식별하기 위해 호스트 내부적으로 할당받는 고유의 값

## section 18 - IP 주소와 포트번호를 TCP/IP 소프트웨어에게 통지한다
DNS 서버에서 알아낸 서버의 IP 주소와 미리 정해진 포트번호를 통지하여 TCP/IP 소프트웨어에 접속을 요청한다 그러면 TCP/IP 소프트웨어는 통지된 IP 주소의 상대에게 제어용 패킷을 보내서 통신을 시작한다는 것을 알려준다

## section 19 - 서버 쪽 준비동작
서버 측은 클라이언트로부터 패킷이 도착하기 전에 준비가 필요함
- socket, bind, listen, accept 라는 프로그램을 호출함
- 클라이언트와 마찬가지로 소켓을 만듬
- bind 동작은 socket으로 만든 소켓에 정보를 등록(통신을 허가하는 IP 주소와 자기 자신의 포트 번호)
   - IP 주소는 통신을 시작하는 통지가 도착해쓸때 그것이 어디에서 왔는가 조사하여 통신을 허가하느냐 거부하느냐를 판단하기 위해 사용
     - 특정한 클라이언트하고 통신하고 싶은 경우 거기에 IP 주소를 설정(모든 클라이언트와 통신하는 경우 0)
   - 포트번호는 TCP/IP 소프트웨어가 패킷을 수신했을 때 그것을 어떤 애플리케이션에 넘길 것인지 판단할 때 사용한다.
     - 즉 bind로 지정한 포트번호를 소켓에 등록해두고 그것과 같은 값을 가지는 패킷이 도착하면 그 포트번호를 등록한 프로그램에 데이터를 넘기는 것
- bind로 소켓에 값을 등록했으면 다음은 listen을 호출하여, 그 소켓이 클라이언트에 접속 대기중임을 TCP/IP 소프트웨어에 통지한다. 그러면 accept 를 호출하게 된다. 이것으로 서버는 클라이언트로부터의 통신을 시작하는 제어 패킷을 기다리는 상태가 된다

## section 20  - 서버측은 IP 주소를 대조하여 접속을 허가한다
이 상태에서 클라이언트에서 통신의 시작을 알리는 제어 패킷이 도착하면 bind로 설정한 IP 주소와 대조하여 통신을 허가하느냐, 거부하느냐를 판단하고, 응답 패킷을 보낸다 이것으로 접속 동작은 끝난다.<br>
서버측에서는 accept가 이 접속 동작을 실행하여 그것이 끝나면 제어를 애플리케이션에 돌려주고, 동시에 새로운 디스크립터를 애플리케이션에 넘겨준다. 디스크립터는 소켓을 식별하는 것이므로 새로운 디스크립터를 넘긴다는 것은 
새로운 소켓이 내부에서 만들어진다는 것이다. 그리고 클라이언트와의 통신에는 그 새로운 소켓을 사용한다<br>

접속을 대기하고 있던 낡은 소켓은 그대로 유지되며 다른 클라이언트에서 통신을 시작하는 제어 패킷을 기다린다. 그리고 젒고 요청을 받으면 다시 새로운 소켓을 생성한 후 그 소켓을 이용하여 통신을 한다. 이렇게 새로운 소켓을 차례로 만들기 때문에 여러 개의 클라이언트와 통신할 수 있다.

## section 21 - 메시지 송수신을 시작하다.
- 이후 클라이언트는 write를 호출함 (송신 데이터와 그 데이터의 길이를 넘겨줌)
- 그러면 TCP/IP 소프트웨어가 그 데이터를 서버에 보냄(웹 브라우저가 만든 HTTP request 메시지)
- 서버의 TCP/IP 소프트웨어는 이 메시지를 내부의 버퍼 메모리에 저장
- 이후 read를 호출하면 수신 버퍼용 메모리 영역을 함께 알리게 되므로 TCP/IP 소프트웨어는 그 메모리 영역에 데이터를 저장한 후 서버 프로그램에 제어를 돌려줌
- response 메시지를 만들어 파일 내용이나 CGI 프로그램의 출력 데이터를 저장하고, write를 호출하여 클라이언트로 돌려보냄
- response 메시지가 클라이언트에 도착하면 클라이언트측에서는 웹 브라우저가 read를 호출하여 그 데이터를 받아들임

## section 22 - 메시지 송수신의 끝을 알려준다
이것으로 클라이언트와 서버의 송수신 과정은 끝났다 그 당므은 close를 호출하여 통신의 종료를 알리는 패킷을 보낸다
- TCP/IP 규칙은 어느 쪽에서 통신을 종료해도 상관이 없지만 웹 액세스의 경우 서버측에서 통신을 종료한다.
  - 그러면 클라이언트 측에서는 read를 호출했을 때의 반환값으로 통신이 종료되었음을 애플리케이션에게 알려준다
-그러면 클라이언트 측에서도 close를 호출한다(close 후 소켓은 사라짐)
<br>
이렇게 아나의 송수신이 끝나면 접속을 끊고, 여러 데이터의 송 수신을 할 때는 접속 동작부터 다시 시작하는 것이 HTTP 의 원래의 동작이지만, 페이지에 드림 등이 들어 있어 여러 개의 데이터를 읽어드링는 경우 접속과 끊기를 되풀이하는 것은 낭비이다. 그래서 일단 접속하고나면 끊지 않고 여러 개의 요청과 응답을 주고받을 수 있는 방법도 마련되어 있다. HTTP 1.1 버전에서는 그 방법을 사용할 수 있다
<br>
메시지를 실제로 송수신하는 것은 TCP/IP 소프트웨어, LAN 드라이버, LAN 어댑터 등 세 가지인데 이 세가지가 연동하여 네트워크로 데이터가 흘러간다 다음장에서 공부해보자
