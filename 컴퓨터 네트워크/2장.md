워밍업
1. 패킷을 받는 수신자의 IP 주소는 TCP 헤더와 IP 헤더 중 어느쪽에 포함되어 있을까?
2. 서버 프로그램의 종류를 지정하기 위해 사용하는 포트번호는 TCP 헤더와 IP 헤더 중 어느쪽에 포함되어 있을까?
3. 패킷이 올바르게 도착했는지 여부를 확인하는 것은 TCP 와 IP 중 어느쪽일까?
4. 이더넷의 MAC 주소는 몇 비트로 이루어져 있을까?
5. 트위스티드 페어 케이블 길이에는 제한이 있는ㅈ데, 몇 미터까지 제한할까?
<br>
<br>

- 2 장에는 거의 모든 section에 그림이 있으니 책을 위주로 공부한느 것이 중요하다 

1.IP 헤더
- IP 헤더에는 패킷을 목적지로 전송할 때 필요한 제어정보를 담고있는데 수신자 주소는 그 중에서 가장 중요한 정보이다
2. TCP 헤더
- TCP 헤더에는 통신 상대와 데이터를 올바르게 주고받기 위해 필요한 제어정보가 담겨있는데, 포트번호는 통신 상대의 프로그램을 지정하는 중요한 정보이다. 
3. TCP 
- TCP는 패킷이 올바르게 도착했는지 확인하고, 도착하지 않았을 때는 패킷을 다시 보낸다
4. 48비트
- MAC 주소는 48비트이며, 전세계적으로 중복되지 않도록 일관적으로 관리하고 있다
5. 100미터
- 이더넷의 표준은 트위스티드 페어를 사용했을 경우, 100미터까지의 거리를 보장하고 있다. 그러므로 그 이상의 거리에서는 정상적으로 통신할 수 없게 될 가능성이 커진다.
<br>
<br>

## section 1 TCP-IP 소프트웨어의 내부 구성
1장에서 주소란에 입력된 URL을 해석하고 이를 바탕으로 HTTP 리퀘스트 메시지를 만ㄷ르어 TCP/IP 소프트웨어에 송신을 요청하는 과정을 알아봤다
<br>

이번 장에서는 메시지를 웹 서버를 향해 내보내는 부분을 알아본다

<br>

우선 TCP/IP의 메시지를 패킷의 형태로 바꾸는 것을 이해하려면 TCP/IP 의 구조에 대해서 알아야 한다. (책 그림 참고)
- 가장 위(네트워크 애플리케이션)
  - 웹서버, 메일 서버와 같은 프로그램이 이에 해당
  - 여기서 부터 아래를 향해 데이터 송수신을 요청
- OS
  - 네트워크 애플리케이션 아래 계층 TCP/IP, UDP 층과 IP층이 있음
  - TCP/IP 소프트웨어가 위치
  - TCP/IP 에는 TCP라는 프로토콜을 써서 데이터 송수인을 제어하는 부분과,
  - UDP라는 프로토콜을 사용해서 데이터 송수신을 제어하는 부분이 있음
  - 웹, 메일 등 일반적인 애플리케이션 -TCP
  - DNS 서버로의 질의 짧은 제어용 데이터를 송수신하는 경우 UDP
  - TCP/IP , UDP 아래에는 IP 프로토콜을 사용해서 패킷 송수신 동작을 제어하는 부분이 있음
  - 인터넷에서 데이터를 전송할 때 데이터를 잘게 나눈 패킷이라는 형태로 전송하는데 그 패킷의 송수신을 제어하는 것이 IP의 주된 역할
  - IP에는 ICMP와 ARP 가 포함되어 있음
  - ICMP는 패킷을 전송했을 때 오류가 생겼을 경우 통지하는 역할을 하고
  - ARP 는 이더넷의 MAC 주소를 조회할 때 사용

- IP 아래에 있는 LAN 드라이버는 LAN 카드의 하드웨어를 제어하는 것이고, 그 아래에 있는 LAN 카드가 실제의 송수신동작, 즉 케이블에 신호를 송수신하게 된다.


- 메시지를 전송하는 첫 단계
  - TCP/IP 소프트웨어로 메시지를 패킷의 형태로 바꾼다.

## section 2 - 소켓의 실체는 TCP/IP 소프트웨어 내부의 메모리
- 소켓의 실체는 TCP/IP 소프트웨어 내부에서 관리하는 메모리 영역임 TCP를 쓰느냐 UDP를 쓰느냐, 통신 동작이 어떤 진행상태에 있는가 등을 나타내는 제어 정보가 저장되어 있음 TCP/IP 소프트웨어 내부에 있는 TCP,UDP,IP와 같은 프로그램은 이것을 참조하면서 동작
- 또한 통신상태에 대한 정보를 저장해두는데 통신을 하고 있는지, 하고 있다면 해당 애플리케이션은 몇번 포트를 이용하고 있는지를 저장한다 cmd에서 netstat -ano 를 했을 때 보이는 행 하나하나가 소켓이라고 보면 된다.

## section 3 
책에 그림이 있으므로 책을 보는 것이 나음<br>
결과적으로 네트워크에서 송수신할 때 하나의 웹 서버 컴퓨터에서 여러 개의 웹 서버 프로그램을 실행할 때 다른 서버 프로그램들이 같은 포트를 사용하게 되는데 이 때 여러개의 클라이언트의 요청 중에서 어떤 클라이언트가 어떤 서버 프로그램을 이용할지는 클라이언트 쪽의 포트와 IP 주소로 구분할 수 있다<br>
TCP/IP 소프트웨어는 이와 같이 소켓을 조사해서 수신한 데이터를 어느 서버 프로그램에 넘겨야 하는지를 판단하는데 이 떄문에 수신측의 IP 줏와 포트번호, 송신측의 IP 주소와 포트 번호 네 가지가 모두 같은 값을 갖는 소켓이 두 개 이상인 경우에는  데이터를 넘기는 서버 프로그램을 판단할 수 없게 된다
<br> 따라서 이 같은 경우에는 통신오류가 발생한다.

## section 4 - TCP/IP 소프트웨어는 먼저 소켓을 작성한다
소켓이 생성과 사용
1. DNS 서버에 질의 하는 동작
2. 소켓을 만들 때 OS 에 요청하여 소켓 하나 만큼으 메모리 영역을 확보
3. 확보한 메모리 영역에 제어 정보를 기록(IPv4 사용 ,TCP 사용 등)
4. 소켓 생성이 끝나고 통신준비가 끝나면 socket은 호출한 애플리케이션에게 디스크립터를 반환
5. 디스크립터를 받은 애플리케이션은  이후 TCP/IP 소프트웨어에 데이터 송수신 동작을 요청할 때 통신 상대의 정보 대신 디스크립터를 알려줌

<br> 

소켓의 호출 순서
1. DNS 서버와 IP 주소를 문의하는 메시지를 교환
2. 통신 게시를 알리는 제어용의 패킷을 교환
3. 송신 데이터를 상대에 송신
4. 상대로부터 보내온 데이터를 수신
5. 통신 종료를 알리는 제어용의 패킷을 교환

## section 5 - 소켓을 만든 후 TCP로 파이프를 연결한다
- 소켓을 생성한 후 소켓 라이브러리에 있는 connect라는 프로그램을 호출하여 통신시작을 알리는 제어 정보를 주고 받음
- connect에는 통신 상대의 주소와 애플리케이션의 포트 번호가 넘겨지고 클라이언트측 프로그램과 서버측 프로그램의 포트를 논리적으로 연결한다
- 마찬가지로 close를 하면 논리적 연결 해제

## section 6 - 접속, 데이터 송숫신, 종료의 3단계로 관리
커넥션에 대한 동작을 제어하면서 데이터를 전송하는 것이 TCP의 역할
- 최초의 접속 단계는 다음과 같이 동작. 먼저 접속하려는 쪽이 접속을 기다리는 쪽에 지금부터 데이터를 보낸다는 전송 제어 정보를 담은 패킷을 보냄
- 접속을 기다리던 서버측은 이에 OK 응답을 하면서 데이터 전송 제어정보를 보냄 (하나의 패킷에 통신 개시와 수신확인의 두 가지 정보를 실어서 되돌려보내는 것
- 접속하는 측이 확인 응답을 함
TCP 데이터 송수신은 전이중 방식으로(두 대의 단말기가 데이터를 송수신하기 위해 동시에 각각 독립된 회선을 사용하는 통신방식) 통신함<br>
따라서 양방향으로 데이터를 주고받을 수 있는데 양방향 데이터 송신 동작이 독립되어 서로 영향을 받지 않고 동작함 그러므로 각각의 방향으로 제어 정보를 따로따로 통지하게 되고 제어정보를 통지하면 반드시 이에대한 확인 응답을 보내야함
제어정보를 주고 받는 과정에서 오류가 발생할 수 있기 떄문에 정상적으로 패킷이 도착했다는 것을 알리기 위해 반드시 수신 확인 응답을 보내는 것
<br>

마찬가지로 데이터 송수신 차례도 전이중 방식이므로 송신데이터를 가진 측은 언제라도 데이터를 보낼 수 있음
데이터를 보냈으면 수신한 측은 올바르게 도착했음을 나타내는 수신 확인 응답을 보냄 이 동작을 반복하여 데이터를 전부 보내면 데이터 송수신은 끝남
<br>
데이터 송수신이 끝나면 연결 종료 단계로 넘어가고 이 단계는 어느 쪽이 시작해도 상관 없음 더 이상 보낼 데이터가 없다라고 판단하는 쪽에서 보낼 데이터가 없다는 것을 알리면 수신하는 측은 알았다고 응답을 한다.
TCP는 한 쪽이 연결 종료에 들어가면, 다른 쪽도 신속히 종료 단계에 들어가므로 수신 측 응답 이후 연결 종료

## section 7 - 제어 정보를 담는 TCP 헤더를 만든다
![image](https://github.com/kdfasdf/TIL/assets/96770726/865a5653-060e-43c5-8163-106f1fb371fb)
<br>

- 제어비트 SYN의 값이 1이면 데이터를 보낸다는 의미, ACK 비트가 1이면 응답 확인을 의미


## section 8 - IP 주소를 담는 IP 헤더를 만든다(4장에서 제대로 설명)

![image](https://github.com/kdfasdf/TIL/assets/96770726/60883e7c-1212-420a-adbe-1b968194eec9)


TCP 헤더를 만들면 IP 에 넘기면 IP는 IP 헤더를 만들어서 TCP 헤더 앞쪽에 붙임<br>
connect에서 지정된 목적지 IP 주소를 헤더에 입력
IP는 스스로 보낼 곳을 판단하는 것이 아니라 애플리케이션의 요청에 따라서 패킷 송신 동작을 실행할 뿐이므로, 만일 애플리케이션이 잘못된 IP 주소를 지정했더라도 그 IP 주소를 그대로 설정한다.(이 경우 정상동작 X)

- 라우팅 테이블(책 그림, 설명 참고)
  - 수신할 측의 IP 주소를 설정할 때 수신하는 측이 여러 개의 LAN 카드를 사용한다면 어떤 IP 주소를 설정할 것인가를 판단해야하는데 이 떄 사용하는 것

## section 9 - 이더넷용으로 MAC 헤더를 만든다
IP 헤더를 만든 이후에는 이더넷에 패킷을 전송하기 위해 MAC 헤더를 만들어야 함<br>
- 이더넷의 특징은 송신한 신호가  LAN 전체에 보내지는 것이다(수신 목적지와 패킷이 일치하면 수신하고 그 밖의 장비들은 패킷을 버림)
- MAC 헤더(14 바이트)
  - 수신자 MAC 주소(48비트)
    - 이 패킷을 보낼 상대의 MAC 주소, LAN 에서의 패킷 배송은 이 주소에 의거해 이루어짐
    - IP주소로부터 수신자의 MAC 주소를 조사하는 동작을 실행하여 알아냄
  - 송신자 MAC 주소(48비트)
    - 이 패킷을 송신한 측의 MAC 주소, 패킷을 받았을 때 이 값에 의해 누가 보냈는지를 판단
    - LAN카드에 내장된 ROM 에 저장된 MAC 주소를 헤더에 설정 
  - 이더넷 타입(16비트)
    - 사용하는 프로토콜의 종류를 나타낸다 (IEEE,IP프로토콜,ARP프로토콜,IPv6)
## section 11 - IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
- MAC 헤더를 IP 헤더 앞에 붙이면 패킷은 완성 IP 가 만든 여기까지가 IP의 담당
- 이후 LAN 카드에서 패킷을 전기나 광신호로 변환하여 네트워크 케이블에 내보내게 됨
- LAN 카드 역시 다른 하드웨어 소프트웨어와 마찬가지로 OS 시동시 초기화 작업 수행 + 이더넷 특유의 작업
- LAN카드의 ROM에 저장된 MAC 주소를 읽어서 이더넷 컨트롤러에 설정
LAN 카드 드라이버는 IP에서 패킷을 받으면 그것을 LAN 카드 내의 버퍼 메모리에 저장한다. 저장이 끝나면 그 패킷을 송신하도록 이더넷 컨트롤러에 명령을 보낸다

## section 12 - 패킷에 3 개의 제어용 데이터를 덧붙인다 
이더넷 컨트롤러는 송신 패킷을 버퍼 메모리에서 꺼내어 첫머리에 '프리앰블'과 '스타트프레임 델리미터'라는 두 가지 데이터를 추가하고 
 끝에는 '프레임 체크 시퀀스' 라는 오류 검출용의 데이터를 추가한다

 - 프리앰블
   - 1과 0이 교대로 나타나는 비트열이 56비트만큼 계속하는 것(101010...)
 - 스타트 프레임 델리미터(8비트분)
   - 수신측은 이 델리미터를 기준으로 신호에서 데이터를 추출함
- FCS
  - 패킷을 전송하는 도중 잡음 등의 영향으로 파형이 흩어져서 데이터가 변형되어 버린 경우에 그것을 검출하기 위해 사용한다
 
## section 13 - 허브를 향해 접속을 알리는 패킷을 전송한다
프리앰블, 스타트 프레임 델리미터, FCS의 셋을 부가했으면 케이블로 보내는 패킷을 완성한 것 이더넷의 송신 동작에는 리피터 허브를 사용했을 때의 반이중 동작과
스위칭 허브를 사용하는 전이중 동작의 두 가지가 있음
MAC 헤더는 LAN 카드에서 처리한다고 생각하기 쉬우나 실제로는 TCP/IP 소프트웨어가 처리
- 반 이중 동작
  - 장비가 ㄲ있으면 송신이 끝날 때까지 기다리고, 아무도 송신중이 아닐 때 송신한다는 간단한 규칙에 따라서 움직임
  - 이더넷 컨트롤러는 케이블에 신호 흐름 여부를 확인하고 르르면 끝날 때까지 기다리고 흐르지 않으면 송신동작에 돌입
  - 프리앰블 첫 머리부터 차례로 1비트씩 전기신호로 변환하여 MAU 에 보냄(이 때 신호로 변환하는 속도가 전송 속도
  - MAU에 신호를 보내고나면 MAU에서 케이블로 송출하는 형식
 
## section 14  LAN 카드의 MAU가 충돌을 검출한다
MAU는 이더넷 컨트롤러에서 받은 신호를 케이블에 송출할 때 단지 송신 동작만 하는 것이 아니라, 수신 신호선에서 신호가 들어오지 않는지도 감시한다.
(단 이더넷이라는 방식은 송신한 신호가 상대에게 제대로 도착했는지를 확인하지 않게 되어있다)

- 리피터 허브
  - 이더넷의 허브를 말한다. 종래의 신호를 증폭하여 중계하는 타입의 허브와 스위칭 허브를 구별할 때 전자의 것을 가리켜서 리피터 허브라고 한다 셰어드 허브, 공유 허브라고 한다
- MAC 주소
  - IEEE에서 표준화된 LAN 방식의 장비는 모두 같은 형식의 주소를 쓰게 되어 있으며, 이 LAN 장비에 할당된 주소를 MAC 주소라고 한다.
  - 길이는 전부 48비트 상위 24비트가 제조사에 할당되고 그 값으로 제조사를 식별할 수 있다
  - 하위 24 비트가 개개의 인터페이스를 식별하는 값으로 되어있다
  - 대부분의 제품은 공장에서 출하될 경우 ROM 등에 주소가 기록되므로 사용자가 MAC 주소를 설정하는 일은 거의 없다

- 이더넷의 스펙은 장비와 장비 사이를 잇는 케이블의 길이를 100미터 이내로 정하고 있다 불과 100미터의 케이블에 신호를 흘릴뿐 이므로 오류는 거의 발생하지 않는다. 만일 오류가 발생한다 하더라도 상위의 TCP/IP 소프트웨어의 TCP 가 검출하게 된다그러므로 패킷 송신 동작으로 오류를 확인할 필요는 없다

- 충돌
  - 신호를 송신하는 동안 수신신호가 아주 낮은 확률로 들어오는 경우가 있는데 (동시에 여러 장비가 송신 동작에 들어갈 수 있기 떄문) 리피터 허브를 이용하는 반이중 동작의 경우가 이런 상태가 되면 상호간의 통신이 구분할 수 없는 상태가 되는데 이 현상을 충돌이라고 한다 충돌이 일어나면 송신을 멈추고 충돌이 일어난 것을 다른 장비에게 알리기 위해 재밍(jamming) 이라는 특수한 신호르 잠시 동안 보낸 후 송신 동작을 멈춘다. 그리고 잠시 기다렸다가 송신 동작을 다시 시도하는데 충돌을 일으킨 장비의 대시시간이 같으면 다시 충돌해 버리므로 대기 시간이 다르게 해야한다. 만약 대기시간을 조정하더라도 반복적으로 충돌이 일어난다면 송신 오류로 간주한다
  - 다른 한편 전이중 방식은 송신과 수신을 동시에 할 수 있으므로 충돌이 일어나지 않는다
 
## section 15 - 통신 개시에 대한 응답 패킷을 받는다
- 클라이언트 측에서 송신한 신호는 모두에게 전달되는데 수신한 측들은 FCS(Frame Check Sequence)를 통해 잡음에 영향을 받은 패킷인지 아닌지 부터 판별
- FCS에 문제가 없으면 MAC 헤더의 목적지 주소를 비교하고 수신하는 측의 MAC 주소와 일치하면 송신한 클라이언트 측에 패키시 수신 사실을 통지한다
- 패키지 수신 사실은 LAN 카드가 컴퓨터에 인터럽트를 하여 알림
- 자세한 인터럽트 과정은 운영체제에서의 interrupt service routine 과 같은 과정으로 이루어짐 
