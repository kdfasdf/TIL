워밍업
1. 패킷을 받는 수신자의 IP 주소는 TCP 헤더와 IP 헤더 중 어느쪽에 포함되어 있을까?
2. 서버 프로그램의 종류를 지정하기 위해 사용하는 포트번호는 TCP 헤더와 IP 헤더 중 어느쪽에 포함되어 있을까?
3. 패킷이 올바르게 도착했는지 여부를 확인하는 것은 TCP 와 IP 중 어느쪽일까?
4. 이더넷의 MAC 주소는 몇 비트로 이루어져 있을까?
5. 트위스티드 페어 케이블 길이에는 제한이 있는ㅈ데, 몇 미터까지 제한할까?
<br>
<br>

- 2 장에는 거의 모든 section에 그림이 있으니 책을 위주로 공부한느 것이 중요하다 

1.IP 헤더
- IP 헤더에는 패킷을 목적지로 전송할 때 필요한 제어정보를 담고있는데 수신자 주소는 그 중에서 가장 중요한 정보이다
2. TCP 헤더
- TCP 헤더에는 통신 상대와 데이터를 올바르게 주고받기 위해 필요한 제어정보가 담겨있는데, 포트번호는 통신 상대의 프로그램을 지정하는 중요한 정보이다. 
3. TCP 
- TCP는 패킷이 올바르게 도착했는지 확인하고, 도착하지 않았을 때는 패킷을 다시 보낸다
4. 48비트
- MAC 주소는 48비트이며, 전세계적으로 중복되지 않도록 일관적으로 관리하고 있다
5. 100미터
- 이더넷의 표준은 트위스티드 페어를 사용했을 경우, 100미터까지의 거리를 보장하고 있다. 그러므로 그 이상의 거리에서는 정상적으로 통신할 수 없게 될 가능성이 커진다.
<br>
<br>

## section 1 TCP-IP 소프트웨어의 내부 구성
1장에서 주소란에 입력된 URL을 해석하고 이를 바탕으로 HTTP 리퀘스트 메시지를 만ㄷ르어 TCP/IP 소프트웨어에 송신을 요청하는 과정을 알아봤다
<br>

이번 장에서는 메시지를 웹 서버를 향해 내보내는 부분을 알아본다

<br>

우선 TCP/IP의 메시지를 패킷의 형태로 바꾸는 것을 이해하려면 TCP/IP 의 구조에 대해서 알아야 한다. (책 그림 참고)
- 가장 위(네트워크 애플리케이션)
  - 웹서버, 메일 서버와 같은 프로그램이 이에 해당
  - 여기서 부터 아래를 향해 데이터 송수신을 요청
- OS
  - 네트워크 애플리케이션 아래 계층 TCP/IP, UDP 층과 IP층이 있음
  - TCP/IP 소프트웨어가 위치
  - TCP/IP 에는 TCP라는 프로토콜을 써서 데이터 송수인을 제어하는 부분과,
  - UDP라는 프로토콜을 사용해서 데이터 송수신을 제어하는 부분이 있음
  - 웹, 메일 등 일반적인 애플리케이션 -TCP
  - DNS 서버로의 질의 짧은 제어용 데이터를 송수신하는 경우 UDP
  - TCP/IP , UDP 아래에는 IP 프로토콜을 사용해서 패킷 송수신 동작을 제어하는 부분이 있음
  - 인터넷에서 데이터를 전송할 때 데이터를 잘게 나눈 패킷이라는 형태로 전송하는데 그 패킷의 송수신을 제어하는 것이 IP의 주된 역할
  - IP에는 ICMP와 ARP 가 포함되어 있음
  - ICMP는 패킷을 전송했을 때 오류가 생겼을 경우 통지하는 역할을 하고
  - ARP 는 이더넷의 MAC 주소를 조회할 때 사용

- IP 아래에 있는 LAN 드라이버는 LAN 카드의 하드웨어를 제어하는 것이고, 그 아래에 있는 LAN 카드가 실제의 송수신동작, 즉 케이블에 신호를 송수신하게 된다.


- 메시지를 전송하는 첫 단계
  - TCP/IP 소프트웨어로 메시지를 패킷의 형태로 바꾼다.

## section 2 - 소켓의 실체는 TCP/IP 소프트웨어 내부의 메모리
- 소켓의 실체는 TCP/IP 소프트웨어 내부에서 관리하는 메모리 영역임 TCP를 쓰느냐 UDP를 쓰느냐, 통신 동작이 어떤 진행상태에 있는가 등을 나타내는 제어 정보가 저장되어 있음 TCP/IP 소프트웨어 내부에 있는 TCP,UDP,IP와 같은 프로그램은 이것을 참조하면서 동작
- 또한 통신상태에 대한 정보를 저장해두는데 통신을 하고 있는지, 하고 있다면 해당 애플리케이션은 몇번 포트를 이용하고 있는지를 저장한다 cmd에서 netstat -ano 를 했을 때 보이는 행 하나하나가 소켓이라고 보면 된다.

## section 3 
책에 그림이 있으므로 책을 보는 것이 나음<br>
결과적으로 네트워크에서 송수신할 때 하나의 웹 서버 컴퓨터에서 여러 개의 웹 서버 프로그램을 실행할 때 다른 서버 프로그램들이 같은 포트를 사용하게 되는데 이 때 여러개의 클라이언트의 요청 중에서 어떤 클라이언트가 어떤 서버 프로그램을 이용할지는 클라이언트 쪽의 포트와 IP 주소로 구분할 수 있다<br>
TCP/IP 소프트웨어는 이와 같이 소켓을 조사해서 수신한 데이터를 어느 서버 프로그램에 넘겨야 하는지를 판단하는데 이 떄문에 수신측의 IP 줏와 포트번호, 송신측의 IP 주소와 포트 번호 네 가지가 모두 같은 값을 갖는 소켓이 두 개 이상인 경우에는  데이터를 넘기는 서버 프로그램을 판단할 수 없게 된다
<br> 따라서 이 같은 경우에는 통신오류가 발생한다.

## section 4 - TCP/IP 소프트웨어는 먼저 소켓을 작성한다
소켓이 생성과 사용
1. DNS 서버에 질의 하는 동작
2. 소켓을 만들 때 OS 에 요청하여 소켓 하나 만큼으 메모리 영역을 확보
3. 확보한 메모리 영역에 제어 정보를 기록(IPv4 사용 ,TCP 사용 등)
4. 소켓 생성이 끝나고 통신준비가 끝나면 socket은 호출한 애플리케이션에게 디스크립터를 반환
5. 디스크립터를 받은 애플리케이션은  이후 TCP/IP 소프트웨어에 데이터 송수신 동작을 요청할 때 통신 상대의 정보 대신 디스크립터를 알려줌

<br> 

소켓의 호출 순서
1. DNS 서버와 IP 주소를 문의하는 메시지를 교환
2. 통신 게시를 알리는 제어용의 패킷을 교환
3. 송신 데이터를 상대에 송신
4. 상대로부터 보내온 데이터를 수신
5. 통신 종료를 알리는 제어용의 패킷을 교환

## section 5 - 소켓을 만든 후 TCP로 파이프를 연결한다
- 소켓을 생성한 후 소켓 라이브러리에 있는 connect라는 프로그램을 호출하여 통신시작을 알리는 제어 정보를 주고 받음
- connect에는 통신 상대의 주소와 애플리케이션의 포트 번호가 넘겨지고 클라이언트측 프로그램과 서버측 프로그램의 포트를 논리적으로 연결한다
- 마찬가지로 close를 하면 논리적 연결 해제

## section 6 - 접속, 데이터 송숫신, 종료의 3단계로 관리
커넥션에 대한 동작을 제어하면서 데이터를 전송하는 것이 TCP의 역할
- 최초의 접속 단계는 다음과 같이 동작. 먼저 접속하려는 쪽이 접속을 기다리는 쪽에 지금부터 데이터를 보낸다는 전송 제어 정보를 담은 패킷을 보냄
- 접속을 기다리던 서버측은 이에 OK 응답을 하면서 데이터 전송 제어정보를 보냄 (하나의 패킷에 통신 개시와 수신확인의 두 가지 정보를 실어서 되돌려보내는 것
- 접속하는 측이 확인 응답을 함
TCP 데이터 송수신은 전이중 방식으로(두 대의 단말기가 데이터를 송수신하기 위해 동시에 각각 독립된 회선을 사용하는 통신방식) 통신함<br>
따라서 양방향으로 데이터를 주고받을 수 있는데 양방향 데이터 송신 동작이 독립되어 서로 영향을 받지 않고 동작함 그러므로 각각의 방향으로 제어 정보를 따로따로 통지하게 되고 제어정보를 통지하면 반드시 이에대한 확인 응답을 보내야함
제어정보를 주고 받는 과정에서 오류가 발생할 수 있기 떄문에 정상적으로 패킷이 도착했다는 것을 알리기 위해 반드시 수신 확인 응답을 보내는 것
<br>

마찬가지로 데이터 송수신 차례도 전이중 방식이므로 송신데이터를 가진 측은 언제라도 데이터를 보낼 수 있음
데이터를 보냈으면 수신한 측은 올바르게 도착했음을 나타내는 수신 확인 응답을 보냄 이 동작을 반복하여 데이터를 전부 보내면 데이터 송수신은 끝남
<br>
데이터 송수신이 끝나면 연결 종료 단계로 넘어가고 이 단계는 어느 쪽이 시작해도 상관 없음 더 이상 보낼 데이터가 없다라고 판단하는 쪽에서 보낼 데이터가 없다는 것을 알리면 수신하는 측은 알았다고 응답을 한다.
TCP는 한 쪽이 연결 종료에 들어가면, 다른 쪽도 신속히 종료 단계에 들어가므로 수신 측 응답 이후 연결 종료

## section 7 - 제어 정보를 담는 TCP 헤더를 만든다
![image](https://github.com/kdfasdf/TIL/assets/96770726/865a5653-060e-43c5-8163-106f1fb371fb)
<br>

- 제어비트 SYN의 값이 1이면 데이터를 보낸다는 의미, ACK 비트가 1이면 응답 확인을 의미


## section 8 - IP 주소를 담는 IP 헤더를 만든다(4장에서 제대로 설명)

![image](https://github.com/kdfasdf/TIL/assets/96770726/60883e7c-1212-420a-adbe-1b968194eec9)


TCP 헤더를 만들면 IP 에 넘기면 IP는 IP 헤더를 만들어서 TCP 헤더 앞쪽에 붙임<br>
connect에서 지정된 목적지 IP 주소를 헤더에 입력
IP는 스스로 보낼 곳을 판단하는 것이 아니라 애플리케이션의 요청에 따라서 패킷 송신 동작을 실행할 뿐이므로, 만일 애플리케이션이 잘못된 IP 주소를 지정했더라도 그 IP 주소를 그대로 설정한다.(이 경우 정상동작 X)

- 라우팅 테이블(책 그림, 설명 참고)
  - 수신할 측의 IP 주소를 설정할 때 수신하는 측이 여러 개의 LAN 카드를 사용한다면 어떤 IP 주소를 설정할 것인가를 판단해야하는데 이 떄 사용하는 것

## section 9 - 이더넷용으로 MAC 헤더를 만든다
IP 헤더를 만든 이후에는 이더넷에 패킷을 전송하기 위해 MAC 헤더를 만들어야 함<br>
- 이더넷의 특징은 송신한 신호가  LAN 전체에 보내지는 것이다(수신 목적지와 패킷이 일치하면 수신하고 그 밖의 장비들은 패킷을 버림)
- MAC 헤더(14 바이트)
  - 수신자 MAC 주소(48비트)
    - 이 패킷을 보낼 상대의 MAC 주소, LAN 에서의 패킷 배송은 이 주소에 의거해 이루어짐
    - IP주소로부터 수신자의 MAC 주소를 조사하는 동작을 실행하여 알아냄
  - 송신자 MAC 주소(48비트)
    - 이 패킷을 송신한 측의 MAC 주소, 패킷을 받았을 때 이 값에 의해 누가 보냈는지를 판단
    - LAN카드에 내장된 ROM 에 저장된 MAC 주소를 헤더에 설정 
  - 이더넷 타입(16비트)
    - 사용하는 프로토콜의 종류를 나타낸다 (IEEE,IP프로토콜,ARP프로토콜,IPv6)
## section 11 - IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
- MAC 헤더를 IP 헤더 앞에 붙이면 패킷은 완성 IP 가 만든 여기까지가 IP의 담당
- 이후 LAN 카드에서 패킷을 전기나 광신호로 변환하여 네트워크 케이블에 내보내게 됨
- LAN 카드 역시 다른 하드웨어 소프트웨어와 마찬가지로 OS 시동시 초기화 작업 수행 + 이더넷 특유의 작업
- LAN카드의 ROM에 저장된 MAC 주소를 읽어서 이더넷 컨트롤러에 설정
LAN 카드 드라이버는 IP에서 패킷을 받으면 그것을 LAN 카드 내의 버퍼 메모리에 저장한다. 저장이 끝나면 그 패킷을 송신하도록 이더넷 컨트롤러에 명령을 보낸다

## section 12 - 패킷에 3 개의 제어용 데이터를 덧붙인다 
이더넷 컨트롤러는 송신 패킷을 버퍼 메모리에서 꺼내어 첫머리에 '프리앰블'과 '스타트프레임 델리미터'라는 두 가지 데이터를 추가하고 
 끝에는 '프레임 체크 시퀀스' 라는 오류 검출용의 데이터를 추가한다

 - 프리앰블
   - 1과 0이 교대로 나타나는 비트열이 56비트만큼 계속하는 것(101010...)
 - 스타트 프레임 델리미터(8비트분)
   - 수신측은 이 델리미터를 기준으로 신호에서 데이터를 추출함
- FCS
  - 패킷을 전송하는 도중 잡음 등의 영향으로 파형이 흩어져서 데이터가 변형되어 버린 경우에 그것을 검출하기 위해 사용한다
 
## section 13 - 허브를 향해 접속을 알리는 패킷을 전송한다
프리앰블, 스타트 프레임 델리미터, FCS의 셋을 부가했으면 케이블로 보내는 패킷을 완성한 것 이더넷의 송신 동작에는 리피터 허브를 사용했을 때의 반이중 동작과
스위칭 허브를 사용하는 전이중 동작의 두 가지가 있음
MAC 헤더는 LAN 카드에서 처리한다고 생각하기 쉬우나 실제로는 TCP/IP 소프트웨어가 처리
- 반 이중 동작
  - 장비가 ㄲ있으면 송신이 끝날 때까지 기다리고, 아무도 송신중이 아닐 때 송신한다는 간단한 규칙에 따라서 움직임
  - 이더넷 컨트롤러는 케이블에 신호 흐름 여부를 확인하고 르르면 끝날 때까지 기다리고 흐르지 않으면 송신동작에 돌입
  - 프리앰블 첫 머리부터 차례로 1비트씩 전기신호로 변환하여 MAU 에 보냄(이 때 신호로 변환하는 속도가 전송 속도
  - MAU에 신호를 보내고나면 MAU에서 케이블로 송출하는 형식
 
## section 14  LAN 카드의 MAU가 충돌을 검출한다
MAU는 이더넷 컨트롤러에서 받은 신호를 케이블에 송출할 때 단지 송신 동작만 하는 것이 아니라, 수신 신호선에서 신호가 들어오지 않는지도 감시한다.
(단 이더넷이라는 방식은 송신한 신호가 상대에게 제대로 도착했는지를 확인하지 않게 되어있다)

- 리피터 허브
  - 이더넷의 허브를 말한다. 종래의 신호를 증폭하여 중계하는 타입의 허브와 스위칭 허브를 구별할 때 전자의 것을 가리켜서 리피터 허브라고 한다 셰어드 허브, 공유 허브라고 한다
- MAC 주소
  - IEEE에서 표준화된 LAN 방식의 장비는 모두 같은 형식의 주소를 쓰게 되어 있으며, 이 LAN 장비에 할당된 주소를 MAC 주소라고 한다.
  - 길이는 전부 48비트 상위 24비트가 제조사에 할당되고 그 값으로 제조사를 식별할 수 있다
  - 하위 24 비트가 개개의 인터페이스를 식별하는 값으로 되어있다
  - 대부분의 제품은 공장에서 출하될 경우 ROM 등에 주소가 기록되므로 사용자가 MAC 주소를 설정하는 일은 거의 없다

- 이더넷의 스펙은 장비와 장비 사이를 잇는 케이블의 길이를 100미터 이내로 정하고 있다 불과 100미터의 케이블에 신호를 흘릴뿐 이므로 오류는 거의 발생하지 않는다. 만일 오류가 발생한다 하더라도 상위의 TCP/IP 소프트웨어의 TCP 가 검출하게 된다그러므로 패킷 송신 동작으로 오류를 확인할 필요는 없다

- 충돌
  - 신호를 송신하는 동안 수신신호가 아주 낮은 확률로 들어오는 경우가 있는데 (동시에 여러 장비가 송신 동작에 들어갈 수 있기 떄문) 리피터 허브를 이용하는 반이중 동작의 경우가 이런 상태가 되면 상호간의 통신이 구분할 수 없는 상태가 되는데 이 현상을 충돌이라고 한다 충돌이 일어나면 송신을 멈추고 충돌이 일어난 것을 다른 장비에게 알리기 위해 재밍(jamming) 이라는 특수한 신호르 잠시 동안 보낸 후 송신 동작을 멈춘다. 그리고 잠시 기다렸다가 송신 동작을 다시 시도하는데 충돌을 일으킨 장비의 대시시간이 같으면 다시 충돌해 버리므로 대기 시간이 다르게 해야한다. 만약 대기시간을 조정하더라도 반복적으로 충돌이 일어난다면 송신 오류로 간주한다
  - 다른 한편 전이중 방식은 송신과 수신을 동시에 할 수 있으므로 충돌이 일어나지 않는다
 
## section 15 - 통신 개시에 대한 응답 패킷을 받는다
- 클라이언트 측에서 송신한 신호는 모두에게 전달되는데 수신한 측들은 FCS(Frame Check Sequence)를 통해 잡음에 영향을 받은 패킷인지 아닌지 부터 판별
- FCS에 문제가 없으면 MAC 헤더의 목적지 주소를 비교하고 수신하는 측의 MAC 주소와 일치하면 송신한 클라이언트 측에 패키시 수신 사실을 통지한다
- 패키지 수신 사실은 LAN 카드가 컴퓨터에 인터럽트를 하여 알림
- 자세한 인터럽트 과정은 운영체제에서의 interrupt service routine 과 같은 과정으로 이루어짐 


## section 16 - 서버로부터의 응답 패킷을 IP 에서 TCP로 넘긴ㄴ다
서버에서 돌아온 수신 패킷의 타입은 0800일 것이므로 LAN 드라이버는 IP 에 패킷을 넘긴다. IP 는 다음과 같이 동작한다. IP 헤더부분을 조사하여 포맷에 문제가 있는지 확이나고 문제가 없으면 받을 곳의 IP 주소를 조사한다
패킷을 수신한 장비가 클라이언트 PC인 경우 서버에서 돌아온 패킷의 받을 IP 주소는 수신한 LAN 카드에 할당된 주소와 일치하겠지만, 그렇게 되지 않는 경우도 있다.
서버용의 OS 는 라우터와 같은 패킷 중계 기능을 가지고 있으므로 그 기능ㅇ르 사용하도록 설정되어 있다면 다른 곳으로 중계하는 패킷을 받아들이기도 하기 떄문이다.<br>
클라이언트 PC 인 경우 패킷을 중계할 일이 없으므로 , 받을 곳의 IP 주소와 자신의 주소와 다르다면 어떤 오류가 있다는 말이됨 ICMP는 이러한 오류가 발생했을 때 그것을 송신자에게 통지하는 역할을 함
<br>
이 경우 destination unreachable이라는 오류를 통지(프러그먼테이션, 리어셈블링은 다른 장에서 보기)

- 주요 CMP 메시지

|메시지의 종류|타입|설명|
|--|--|--|
|Echo reply|0|Echo 메시지의 응답|
|Destination unreachable|3|수신측 IP 주소가 경로표에 존재하지 않는 경우 또는 수신측 포트번호를 사용하고 있는 프로그램이 존재하지 않는다는 이유로 패킷을 목적지에 보낼 수 없는 경우는 폐기하도록 되어 있다. 그 때 폐기한 것을 알리기 위해 소스측에 이 메시지를 보냄|
|Source quench|4|라우터의 중계 능력을 넘는 패킷을 보냈을 때 능력을 넘은 만큼의 패킷은 폐기할 수 밖에 없는데 그러한 폐기가 발생한 것을 송신측에게 알릴 때 이 메시지를 쓴다. 단, 반드시 언제나 이 메시지가 송신되는 것은 아니므로 능력 부족으로 이 메시지의 송신도 할 수 없어 패킷을 폐기하는 경우도 있음 또한 이 메시지를 받은 경우는 패킷 송신 페이스를 늦추지 않으면 안됨|
|redirect|5|라우팅 테이블에 의해 중계선을 살핀 결과 패킷의 아웃풋 포트가 그 패킷을 수신한 포트와 같았을 경우 이 라우터를 중계하지 않고 다음 라우터에 직접 패킷을 송신할 수 있게 된다. 그 경우 다음 라우터의 IP 주소를 나타내고 거기에 직접 패킷을 보내도록 통지한다.|
|Echo|8|ping 커맨드에서 쓰는 메시지, 이 메시지를 받은 상대는 Echo reply라는 메시지를 되돌려보낸다. 그것으로 상대가 동작하고 있는지 어떤지를 확인할 수 있다|
|Time exceeded|11|IP 헤더의 TTL 필드로 나타내는 패킷 생존 기간의 값이 마감이 되면 라우터는 패킷을 폐끼한다 그 때 폐기한 것을 알리기 위해 발신원에 이 메시지를 보낸다|
|parameter problem|12|IP 헤더 필드의 값 등에 오류가 있는 경우 패킷을 폐기한다 그 때 폐기한 것을 알리기 위해 발신원에 이메시지를 보낸다|

<br>
IP의 역할이 끝난 후 패킷을 TCP 에 넘김. TCP 는 수신 패킷의 수신측 주소, 수신측 포트번호, 송신측 IP 주소, 송신 측 포트번호 등 네 가지를 살펴본 후 해당하는 소켓을 찾는다.해당하는 소켓을 찾아내먄 그곳에는 접속 동작의 최초 패킷을 보낸 후 그 응답을 기다리고 있는 중이라는 기록이 남아있을 것이다
이것으로 다음의 접속 동작으로 서버가 응답하는 두 번째의 패킷이 도착할 것이다 그리고 도착한 패킷의 TCP 헤더에는 '데이터 송신 개시를 승인합니다 이쪽에서도 데이터를 송신하겠습니다' 라는 의미의 정보가 써 있는 경우 구체적으로는 SYN이 1 ACK가 1로 되어 있으면 접속 동작이 정상적으로 진행하과 있다는 것이다. 그것을 확인했으면 세 번쨰 패킷을 보낸다. 즉 SYN에 0,  ACK에 1을 설정한 TCP 헤더를 만들어 그것을 IP 에 요청하여 상대에게 보낸는 것이다. 이것으로 Socket의 connect 종료, 접속동작 끝난 후 애플리케이션에 제어를 돌려준다


## section 17 - Http 리퀘스트 메시지 패킷을 작성한다
connect 접속 동작 이후 write를 호출하여 HTTP 리퀘스트 메시지를 TCP 에 넘겨준다(이 때 TCP는 메시지를 받게 되지만 받은 데이터의 내용이 무엇인지는 알지 못한다) write를 호출할 때 송신 데이터 길이를 지정하는데 TCP는 그 길이만큼 이진 데이터가 1바이트씩 차례로 배열되어 있다고 인식
<br>TCP는 이 데이터를 받으면 우선 내부 버퍼에 저장, 애플리케이션이 다음 데이터를 넘겨주기를 기다림(TCP는 데이터를 받았다고 바로 송신하지는 않음,바로 송신하면 네트워크 효율이 떨어지기 떄문에)
어느정도 모은 다음에 송신하는가 판단하는 요소
- MTU
  - MTU는 하나의 패킷으로 전송할 수 있는 데이터 크기의 최대값을 말함
  - 이더넷에서는 보통 1500바이트
  - IP 헤더의 첫 머리부터 데이터 맨 끝까지의 최대 길이를 나타냄(IP 헤더 + TCP 헤더 + 데이터)
  - MSS : 보낼 수 있는 데이터의 최대 크기
- 타이밍
  - 애플리케이션의 송신 페이스가 느린경우 MSS 만큼 데이터가 모이는데 오래걸리고 기다리느라 속도저하가 생기므로 적당한 시점에서 송신하는 것
 
## section 18 - 데이터가 클 때는 분할해서 보낸다
- 폼을 사용하는 경우 하나의 패킷에 다 들어가지 않을 정도로 길어지는 경우가 있음
  - 데이터 선두부터 차례로 MSS 크기에 맞추어서 데이터를 분할하고, 그 분할된 조각을 하나의 패킷에 넣어 송신
  - 작게 나누어 보낸 데이터는 수신측의 TCP 에서 그 조각들을 붙여 원래의 데이터로 복원한 후 애플리케이션에 넘긴다
  - IP 프래그먼테이션은 원래 하나였던 패킷을 분할하는 것이지만 TCP의 분할은 분할한 데이터의 조각이 하나의 패킷이 되는 것이므로 그 패킷은 처음부터 하나인 것이므로, IP 프래그먼테이션의 관점에서 보면 분할되어 있지 않은 것이 된다.
 
## section 19 - 도착한 패킷을 ACK 번호로 확인한다(그림 참고)
TCP는 송신한 패킷이 상대방에 제대로 도착했는지 여부를 확인하고 만일 도착하지 않았다면 다시 보내는 기능을 가지고 있음
- 확인 방법
  - TCP 패킷을 보낼 때 그 패킷에 저장한 데이터가 통신 개시부터 시작해 몇 번째 바이트에 해당하는가 하는 정보, 데이터의 크기를 TCP 헤더에 기재(TCP 헤더 시퀀스 필드)
  - 이 두가지를 이용해 송신한 데이터가 몇 번째 바이트부터 시작되고 몇 바이트 분량인지를 알 수 있다 이 정보를 바탕으로 수신측은 데이터를 몇 번째 바이트까지 수신했는가를 계산하고, TCP 헤더의 ACK 번호를 써서 송신측에 알려준다.
 
## section 20 - 패킷의 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
- TCP는 대기 시간을 동적으로 변경하는 방법을 쓰고 있음(ACK 번호가 되돌아오는 시간을 기준으로 하여 대기 시간을 판단)
  - ACK가 돌아오는 시간이 네트워크상 거리차이에 따라 다르므로


## section 21 - 윈도우 제어 방식
매번 응답 받기까지 송신측 컴퓨터가 대기하는 것은 비효율 적이므로 수신측 남는 버퍼가 있다면 응답이 오든말든 패킷을 수신측에 보내는 것

## section 22 - 데이터 송수신 단계의 동작은 접속 단계와 같다
- 이 TCP의 데이터 송신 동작도 접속 동작과 마찬가지로 IP ,LAN카드 드라이버, LAN 카드를 경유하여 패킷 송수신 동작을 한다 그 패킷의 송수신 동작과 접속동작은 거의 같다 IP 이하의 컴포넌트는 일련의 패킷의 관련성을 고려하지 않는다 송수신하는 패킷이 접속동작의 것인지 데이터 송수신의 것인지 수신확인 응답 패킷인지 상관하지 않는다 TCP 헤더나 데이터 부분에 어떤 내용이 써 있는지도 상관하지 않는다 IP 주소나 MAC 주소등의 수신처에 따라서 패킷을 그대로 전송할 뿐, 접속 시의 패킷 송수신 동작과 다르지 않음

## section 23 - HTTP 응답 메시지
- 웹 브라우저로 요청 받아 TCP/IP 소프트웨어가 HTTP 리퀘스트 메시지를 보내는 일련의 동작은 이것으로 끝난다 이렇게 하여 HTTP 리퀘스트 메시지를 보냈으면 웹 서버에서 리스폰스 메시지가 되돌아오는 것을 기다린다 리스폰스 메시지가 도착하면 인터럽트로 패킷을 수신했다는 통지가 있다 그 떄까지 클라이언트는 쉰다

## section 24 - 재전송할 필요가 없는 데이터 송신은 UDP가 효율적이다
오류가 발생해도 다시 보내도 도움이 되지 않는 데이터는 UDP로 데이터를 보내는 편이 효율적이다(수신여부 확인x)
- UDP 헤더

![image](https://github.com/kdfasdf/TIL/assets/96770726/65a30da2-3186-4b60-9dba-df8bf25c42c5)
